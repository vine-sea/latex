\documentclass[UTF8]{ctexart}
\usepackage{anyfontsize}  %去除ctex字體報錯
\usepackage{amsmath}
\usepackage{amssymb} 
\usepackage{extarrows}
\usepackage{titlesec}
\usepackage{titletoc}

\usepackage{pgf}
\usepackage{tikz} % Required for drawing custom shapes
\usetikzlibrary{shapes,backgrounds,arrows,automata}
% \usetikzlibrary{arrows,backgrounds}
% \usepackage{tikz}

\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{setspace}
\usepackage{indentfirst}
\usepackage{booktabs}

% \usepackage{ctex}
\usepackage{listings}

\lstdefinestyle{v1}{
language={C},
basicstyle=\scriptsize\tt,
% basicstyle=\footnotesize\tt,
keywordstyle=\color{blue}\bfseries,
stringstyle=\color{green!50!black},
identifierstyle=\color{yellow!60!black},
showstringspaces=false,
commentstyle=\color{gray},
% backgroundcolor=\color[RGB]{245,245,244},
frameround = tttt,
% frame=shadowbox,
% frame=lines,
frame=single,
tabsize=2,
xleftmargin=2cm, 
xrightmargin=2cm,
rulecolor=\color{gray},  
rulesepcolor=\color{gray}  
} 

\newcommand{\ms}[1]{
    \begin{small}
        #1
    \end{small}
}




 
\renewcommand{\headrulewidth}{0pt}  
\renewcommand{\footrulewidth}{0pt}  
\renewcommand{\headwidth}{\textwidth}

% \newcommand{\ma}[1]{\begin{array}{llll} #1 \end{array}}
% \newcommand{\mb}[1]{\textbf{#1}}
% \newcommand{\meq}[2]{\xlongequal[#2]{#1}}
% \newcommand{\mt}[1]{\text{#1}}
% \newcommand{\p}{\par}
 



\newcommand{\Rmnum}[1]{\uppercase\expandafter{\romannumeral #1}} 
\newcommand{\mR}[1]{\uppercase\expandafter{\romannumeral #1}} 
\newcommand{\mt}[1]{\text{#1}}
\newcommand{\mb}[1]{\textbf{#1}}
\newcommand{\md}[1]{\displaystyle{#1}}
\newcommand{\mda}[1]{$\displaystyle{ #1 }$}
\newcommand{\mf}[1]{\left( #1\right)}
\newcommand{\mfa}[1]{\left| #1\right|}
\newcommand{\mfb}[1]{\left\{ #1\right\}}
\newcommand{\mfc}[1]{\left[ #1 \right]}
\newcommand{\q}{\quad}
\newcommand{\qa}{\vspace{12 pt}}
\newcommand{\mh}[2]{\overset{#2}{#1}}
\newcommand{\mha}[1]{\overrightarrow{#1}}
\newcommand{\p}{\par}
\newcommand{\ma}[1]{\begin{array}{llll} #1 \end{array}}
\newcommand{\tp}[1]{\begin{tikzpicture}  #1 \end{tikzpicture}}
\newcommand{\tpa}[1]{
    \begin{center}
        \begin{tikzpicture}  
            % [scale=1 ,show background rectangle] 
        
            #1 
            \end{tikzpicture}
    \end{center}
}
\newcommand{\tip}[8]{(intersection of #1,#2--#3,#4 and #5,#6--#7,#8)}
\newcommand{\tpo}[2]{\coordinate  %[label=0:$ {#1} $]
 (#1) at #2; }
 \newcommand{\tpoa}[3]{\coordinate  [label=0:$ {#1} $]
 (#3) at #2; }
\newcommand{\da}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\db}[2]{\frac{d #1}{d #2}}
\newcommand{\fcz}[1] {
    \left\{
        \begin{array}{llll} #1 \end{array}
    \right.
}
\newcommand{\hls}[1] {
    \left|
        \begin{array}{llll} #1 \end{array}
    \right|
}
\newcommand{\ba}[1]{\overline{#1}}
\newcommand{\meq}[2]{\xlongequal[#2]{#1}}
\newcommand{\mseq}{\approx }
\newcommand{\jisu}[1]{\sum_{n=0}^\infty #1}
\newcommand{\jixian}[1]{\lim_{n \rightarrow \infty} #1}




\def\ooint{\displaystyle{{\bigcirc}\kern-12.5pt{\int}\kern-7.5pt{\int}}}
\def\oooint{\displaystyle{{\bigcirc}\kern-12.3pt{\int}\kern-7pt{\int}\kern-7pt{\int}}}
 
\def\isleq{\displaystyle{{<}\kern-6.5pt{?} }}






\title{Data Structure}
\author{Vine}
\date{\today}

\geometry{papersize={21cm,29.7cm}}
\geometry{left=1cm,right=1cm,top=2cm,bottom=2cm}
\pagestyle{fancy}


\lhead{Vine }
\chead{}
\rhead{}

\lfoot{}
\cfoot{\thepage }
\rfoot{}


\onehalfspacing




\begin{document}
    

\setlength{\headheight}{15pt}
\maketitle %和頁眉衝突
\newpage
\tableofcontents{}

\newpage
\section{绪论}
\newpage
\section{线性表}
\newpage
\section{栈和队列}
\newpage
\section{串}
\newpage
\section{数组和广义表}
\newpage
\section{树和二叉树}
\newpage
\section{图}
\newpage
\section{动态存储管理}



\newpage
\section{查找}
\begin{lstlisting}[style=v1]
//可能关键字类型
typedef float KeyType;
typedef int KeyType;
typedef char *KeyType;
//可能数据元素类型
typedef struct{
    KeyType key;
    ...
}SElemType;
//数值比较
#define EQ(a,b) ((a)==(b))
#define LT(a,b) ((a)<(b))
#define LQ(a,b) ((a)<=(b))
//字符串比较
#define EQ(a,b) (strcmp(!(a),(b)) )
#define LT(a,b) (strcmp((a),(b))<0)
#define LQ(a,b) (strcmp((a),(b))<=0)

\end{lstlisting}




\subsection{静态查找表}
\subsubsection{顺序表的查找}

\mb{顺序查找}\p
\begin{lstlisting}[style=v1]
typedef struct{ 
    ElemType *elem;
    int length;
}SSTable;

int Search_Seq(SSTable ST,KeyType key){
    //在顺序表ST中查找关键字等于key的数据元素
    //若找到，函数值为该元素在表中位置，否则为0
    ST.elem[0].key=key;                           //哨兵  
    for(i=ST.length;!EQ(ST.ele[i].key,key);--i){  //从后往前找
        return i                                  //找不到时i=0 
    }
}
\end{lstlisting}

\mb{平均查找长度}\p

$$\ma{ASL&=\sum_{i=1}^nP_iC_i\meq{C_i=n-i+1}{}=nP_1+(n-1)P_2+\dots+2P_{n-1}+P_n\\
    ASL_{SS}&=\sum_{i=1}^nP_iC_i\meq{\sum_{i=1}^nP_i=1,P_i=\frac{1}{n}}{C_i=n-i+1}=\frac{1}{n}\sum_{i=1}^n(n-i+1)=\frac{n+1}{2}\\
    ASL_{SS}^{'}&=\sum_{i=1}^nP_iC_i+Q_iD_i\meq{\sum_{i=1}^nP_i=Q_i=\frac{1}{2}}{C_i=n-i+1,D_i=n+1}\frac{1}{2n}\sum_{i=1}^n(n-i+1)+\frac{1}{2}(n+1)=\frac{3(n+1)}{4}
}$$


\subsubsection{有序表的查找}
\mb{折半查找}\p
\begin{lstlisting}[style=v1]
int Search_Bin(SSTable ST,KeyType key){
    //在有序表ST中折半查找关键字等于key的数据元素
    //若找到，函数值为该元素在表中位置，否则为0
    low=1;high=ST.length;           //置区间初值
    while(low<=high){   
        mid=(low+high)/2;
        if(EQ(key,ST.elem[mid].key))return mid;        //找到待查元素
        else if (LT(key,ST.elem[mid].key))high=mid-1;  //继续前半区间查找
        else low=mid+1;                                //继续后半区间查找
    }                   
    return 0;                                          //表中不存在待查元素
}
\end{lstlisting}



\begin{small}
    $$\ma{
    \sum_{j=1}^h j*x^{j-1}&=(\sum_{j=1}^h x^j)^{'}\\
    &=(\frac{x-x^{h+1}}{1-x})^{'}\\
    &=\frac{[1-(h+1)x^h](1-x)+x-x^{h+1}}{(1-x)^2}\\
    \sum_{j=1}^h j*2^{j-1}&\meq{x=2}{}[1-(h+1)2^h](1-2)+2-2^{h+1}\\
    &=(h+1)2^h-1+2-2\cdot 2^h\\
    &=(h-1)2^h+1\\
    2^{h}-1=n \Rightarrow h&=\log _2 (n+1)\\
    ASL_{bs}&=\sum_{i=1}^nP_iC_i\\
    &=\frac{1}{n}\sum_{j=1}^h j*2^{j-1} \mt{(层高*节点数)}\\
    &=\frac{1}{n}[(h-1)2^h+1]\\
    &=\frac{1}{n}[(\log _2 (n+1)-1)2^{\log _2 (n+1)}+1]\\
    &=\frac{1}{n}[(\log _2 (n+1)-1)(n+1)+1]\\
    &=\frac{1}{n}[(\log _2 (n+1))(n+1) -n-1+1]\\
    &=\frac{n+1}{n}\log _2 (n+1)-1\\
    &\approx \log _2 (n+1)-1, (n>50 )
}$$
\end{small}






% \newpage
\subsubsection{静态树表的查找}

$$\ma{sw_i &=\sum_{j=l}^i w_j\\
\Delta P_i &=\mfa{\sum_{j=i+1}^h w_j -\sum_{j=l}^{i-1}w_j}\\
           &=\mfa{(sw_h-sw_i)-(sw_{i-1}-sw_{l-1})}\\
           &\meq{sw_{l-1}=0,w_{l-1}=0}{}\mfa{sw_h+sw_{l-1}-sw_i-sw_{i-1}}
}$$
\begin{center}
    \begin{small}
        \begin{tabular}[b]{ccccccccccc}
            \toprule
            j & 0 & 1 & 2  & 3& 4& 5& 6& 7& 8& 9 \\
            key &  & A & B  &C & D& E& F& G& H& I \\
            \midrule
            $w_i$        & 0 & 1 &1 &2 &5 &3 &4 &4 &3 &5  \\
            $sw_i$       & 0 & 1 &2 &4 &9 &12 &16 &20 &23 &28 \\
            $l=1,h=9,\Delta P_i$  & &27 &25 &22 &15 &7 &0 &8 &15 &23 \\
            $l_1=1,h_1=5,l_1=6,h_1=9,\Delta P_i$  & &11 &9 &6 &1 &19 &  &8 &1 &7  \\
            \bottomrule
        \end{tabular} 
        % \begin{tikzpicture}[  scale=.5,distance=20pt,box/.style={circle,draw}] 
        %     \node[box] {F}
        %     child {node[box] {D}
        %         child {node[box] {B}
        %             child {node[box] {A}} 
        %             child {node[box] {C}} 
        %         } 
        %         child {node[box] {E}} 
        %     } 
        %     child {} 
        %     child {node[box] {H}
        %         child {node[box] {G}} 
        %         child {node[box] {I}} 
        %     } 
        %     ;
        %  \end{tikzpicture}
        \begin{tikzpicture}[scale=.5]
            % \draw[step=1,color=gray!40] (-1,1) grid (8,9);
            \foreach \x/\y/\name in {1/4/B,3/4/E,4/8/F,5/4/G,7/4/I,2/6/D,6/6/H,2/2/C,0/2/A}{
                \node[black,draw,shape=circle,name=\name] at (\x,\y) {\name};
            }
            \foreach \from/\to in {F/D,F/H,D/B,D/E,B/C,H/G,H/I,B/A} {
                \draw (\from)--(\to) ;
            }
        \end{tikzpicture}
    \end{small}
\end{center}




 



\begin{lstlisting}[{style=v1,mathescape}]
typedef BiTree SOSTree;             //次优查找树采用二叉链表存储结构
int SecondOptimal(BiTree &T,ElemType R[],float sw[],int low ,int high){
    //由有序表R[low...high]及其累计权值表sw(sw[0]==1)递归构造次优查找数T
    i=low;min=abs(sw[high]-sw[low]);dw=sw[high]+sw[low-1];
    for(j=low+1;j<=high;++j){               //选择最小$\Delta P_i$值
        if(abs(dw-sw[j]-sw[j-1])<min){
            i=j;min=abs(dw-sw[j]-sw[j-1]);
        }
    }
    T=(BiTree)malloc(sizeof(BiTNode));
    T->data=R[i];                                   //生成节点
    if(i==low) T->lchild=NULL;                      //左子树空
    else SecondOptimal(T->lchild,R,sw,low,i-1);     //构造左子树   
    if(i==high) T->rchild=NULL;                     //右子树空
    else SecondOptimal(T->rchild,R,sw,i+1,high);    //构造右子树    
}

Status CreateSOSTree(SOSTree &T,SSTable ST){
    //有序表ST构造一棵次优查找树T，ST的数据元素含有权域weight
    if(ST.length==0) T=NULL;
    else{
        FindSW(sw,ST);      //按照有序表ST中各元素的weight域求累计权值表sw
        SecondOptimal(T,ST.elem,sw,1,ST.length);
    }
    return OK;
}

\end{lstlisting}



$$\begin{small}
    \ma{
        F_0=0,F_1=1\\    
        F_n&=F_{n-1}+F_{n-2} \q (n \geqslant 2)\\
        F_n-sF_{n-1}&=(1-s)(F_{n-1}+\frac{1}{1-s}F_{n-2}) \q (n \geqslant 2)\\
        &\meq{-s=\frac{1}{1-s}}{}(1-s)(F_{n-1}+sF_{n-2}) \q (n \geqslant 2)\\
        &=(1-s)^{n-1}(F_1+sF_0)  \\
        &=(1-s)^{n-1}\\
        F_n+k(1-s)^{n-1}&=sF_{n-1}+(1+k)(1-s)^{n-1}\\
        &=s[F_{n-1}+\frac{(1+k)}{s}(1-s)^{n-1}]\\
        &=s[F_{n-1}+\frac{(1+k)(1-s)}{s}(1-s)^{n-2}]\\
        &\meq{k=\frac{(1+k)(1-s)}{s}}{}s[F_{n-1}+k(1-s)^{n-2}]\\
        &=s^{n-1}[F_1+k(1-s)^0]\\
        &=s^{n-1}(1+k)\\
        F_n&=(1+k)s^{n-1}-k(1-s)^{n-1}\\
            &=\frac{1 \pm \sqrt{5}}{\pm 2\sqrt{5}}{(\frac{1\pm \sqrt{5}}{2})}^{n-1}- \frac{1 \mp \sqrt{5}}{\pm 2\sqrt{5}}{(\frac{1\mp \sqrt{5}}{2})}^{n-1}\\
            &=\frac{1}{\sqrt{5}}\mfc{\frac{1 \pm \sqrt{5}}{\pm 2 }{(\frac{1\pm \sqrt{5}}{2})}^{n-1}- \frac{1 \mp \sqrt{5}}{\pm 2 }{(\frac{1\mp \sqrt{5}}{2})}^{n-1}}\\
            &=\frac{1}{\sqrt{5}}\mfc{\frac{1 \pm \sqrt{5}}{\pm 2 }{(\frac{1\pm \sqrt{5}}{2})}^{n-1} \mp \frac{1 \mp \sqrt{5}}{ 2 }{(\frac{1\mp \sqrt{5}}{2})}^{n-1}}\\
            &=\fcz{
                \frac{1}{\sqrt{5}}\mfc{\frac{1 + \sqrt{5}}{+ 2 }{(\frac{1+ \sqrt{5}}{2})}^{n-1} - \frac{1 - \sqrt{5}}{ 2 }{(\frac{1- \sqrt{5}}{2})}^{n-1}}\\
                \frac{1}{\sqrt{5}}\mfc{\frac{1 - \sqrt{5}}{- 2 }{(\frac{1- \sqrt{5}}{2})}^{n-1} + \frac{1 + \sqrt{5}}{ 2 }{(\frac{1+ \sqrt{5}}{2})}^{n-1}}\\
            }\\
            &=\frac{1}{\sqrt{5}}\mfc{ {(\frac{1+ \sqrt{5}}{2})}^{n} -  {(\frac{1- \sqrt{5}}{2})}^{n}}\\
            \fcz{
                -s=\frac{1}{1-s}\\
                k=\frac{(1+k)(1-s)}{s}
            }&\Rightarrow\fcz{
                -1-s+s^2=0\\
                ks=1-ks+k-s
            } \Rightarrow\fcz{
                s=\frac{1\pm \sqrt{5}}{2}\\
                (2s-1)k=1-s
            }\Rightarrow\fcz{
                s=\frac{1\pm \sqrt{5}}{2}\\
                1-s=\frac{1\mp \sqrt{5}}{2}\\
                k=\frac{1-s}{(2s-1)}=\frac{1 \mp \sqrt{5}}{\pm 2\sqrt{5}}\\
                1+k=\frac{1 \pm \sqrt{5}}{\pm 2\sqrt{5}}
            }

    }
\end{small}$$


 


\subsubsection{索引顺序表的查找}
 

$$
\ma{    
    ASL_{bs}&=L_b+L_w\\
    &=\frac{1}{b}\sum_{j=1}^bj+\frac{1}{s}\sum_{j=1}^sj\\
    &=\frac{1+b}{2}+\frac{1+s}{2}\\
    &=\frac{1}{2}(\frac{n}{s}+s)+1\\
    ASL_{bs}^{'}&\approxeq \log_2(\frac{n}{s}+1)-1+\frac{1+s}{2}\\
    &\approxeq\log_2(\frac{n}{s}+1)+\frac{s}{2}-\frac{1}{2}\\
    &\approxeq\log_2(\frac{n}{s}+1)+\frac{s}{2} 
}
$$







\subsection{动态查找表}

\subsubsection{二叉排序树和平衡二叉树}
\mb{二叉排序树及其查找过程}\p
\mb{二叉排序树}是空树或者具有性质$\ma{
    \mt{(1)非空左子树上所有节点小于根节点}\\
    \mt{(2)非空右子树上所有节点大于根节点}\\
    \mt{(3)左右子树分别为二叉排序树}\\
}$


\newpage

\mb{二叉排序树的插入和删除}\p
\begin{lstlisting}[style=v1]
    Status SearchBST(BiTree T,KeyType key,BiTree f,BiTree &p){
        //二叉排序树T中查找key
        //成功p指向节点，返回TRUE，失败p指向访问节点，返回FALSE
        //f指向双亲节点，初始值为NULL
        if(!T){p=f;return FALSE;}  //查找失败
        else if EQ(key,T->data.key){p=T;return TRUE;} //查找成功
        else if LT(key,T->data.key) return SearchBST(T->lchild,key,T,p);
        else  return SearchBST(T->rchild,key,T,p);
    }

    Status InsertBST(BiTree &T,ElemType e){
        //二叉排序树T中不存在key，插入e返回TRUE
        //否则返回FALSE
        if(!SearchBST(T,e.key,null,p)){
            s=(BiTree)malloc(sizeof (BiTNode));
            s->data=e;s->lchild=s->rchild=NULL;
            if(!p)T=s;
            else if(LT(e.key,P->data.key))p->lchild=s;
            else p->rchild=s;
            return TRUE;
        }
        else return FALSE;
    }


\end{lstlisting}

双亲节点$*f$删除节点$*p\ma{
    p_L,p_R\mt{均为空树,改双*f亲指针}\\
    p_L \, or \, p_R\mt{为空树，子树为双亲*f子树}\\
    p_L,p_R\mt{均不为空树，}\ma{
        (1)p_L\mt{为双亲*f左子树},p_r\mt{为}p_L\mt{最右}\\
        (2)p_L\mt{最右*s替代}*p，\mt{删除}*s\mt{重复操作}\\
    }
}$

% $$\ma{\sum_{j=1}^n -\ln n=\gamma\approx 0.577   \mt{(欧拉常数)}\\
% \frac{1}{2}<\sum_{j=1}^n -\ln n=\gamma <1 \\
% \sum_{j=2}^n -\ln n<0\\
% \sum_{j=2}^n<\ln n
% }$$

$$\ma{
    \int_1^n \frac{1}{x}dx=\ln n<1+\frac{1}{2}+\frac{1}{3}+\dots+\frac{1}{n-1}=k+\frac{1}{n}\\
    \int_1^n \frac{1}{x}dx=\ln n>\frac{1}{2}+\frac{1}{3}+\frac{1}{3}+\dots+\frac{1}{n}=k-1\\
    \int_1^n \frac{1}{x}dx=\ln n<\frac{1}{2}(1+\frac{1}{2})+\frac{1}{2}(\frac{1}{2}+\frac{1}{3})+\frac{1}{2}(\frac{1}{3}+\frac{1}{4})+\dots+\frac{1}{2}(\frac{1}{n-1}+\frac{1}{n})=k-\frac{1}{2n}-\frac{1}{2}\\
    k=\sum_{j=1}^n \frac{1}{j}\\
    \sum_{j=1}^n\frac{1}{j} -\ln n=\gamma\approx 0.577   \mt{(欧拉常数)}\\
    \frac{1}{2}<\sum_{j=1}^n\frac{1}{j} -\ln n=\gamma <1 \\
    \sum_{j=2}^n\frac{1}{j} -\ln n<0\\
    \sum_{j=2}^n\frac{1}{j}<\ln n\\
}$$




\mb{二叉排序树的查找分析}\p
\mb{平衡二叉树}\p
\mb{平衡二叉树查找的分析}\p




\subsubsection{B-树和B+树}
\subsubsection{键树}






\subsection{哈希表}





\newpage
\section{内部排序}


\subsection{概述}

\begin{lstlisting}[style=v1]
 #define MAXSIZE 20
 typedef int KeyType;
 typedef struct{
    KeyType key;
    InfoType ontherinfo;
 }RedType;
typedef struct{
    RedType r[MAXSIZE+1];
    int length;
}Sqlist;
\end{lstlisting}


\subsection{插入排序}
\subsubsection{直接插入}

\begin{lstlisting}[style=v1]
    void InsertSort(Sqlist &L){
        //对顺序表做直接插入排序
        for(i=2;i<=L.length;i++){
            if(LT(L.r[i].key,L.r[i-1].key)){ //"<",需将L.r[i]插入有序子表
                L.r[0]=L.r[i];               //复制为哨兵
                L.r[i]=L.r[i-1];
                for(j=i-2;LT(L.r[0].key,L.r[j].key);--j)
                    L.r[j+1]=L.r[j];         //记录后移  
                L.r[j+1]=L.r[0];             //插入正确位置
                printf("vine");
            }
        }
    }//InsertSort
\end{lstlisting}

\subsubsection{其他插入}

\mb{折半插入}
\begin{lstlisting}[style=v1]
    void BInsertSort(Sqlist &L){
        //对顺序表做折半插入排序
        for(i=2;i<=L.length;i++){
            L.r[0]=L.r[i];                  //将L.r[i]暂存到L.r[0]
            low=1,high=i-1;
            while(low<=high){               //在L.r[low...high]中折半查找有序插入位置
                m=(low+high)/2;             //折半
                if(LT(L.r[0].key,L.r[m].key)) high=m-1; //插入点在高
                else low =m+1;                          //插入点在低   
            }
            for(j=i-1;j>=high+1;--j) L.r[j+1]=L.r[j];   //记录后移
            L.r[high+1]=L.r[0];                         //插入
        }
    }//BInsertSort
\end{lstlisting}\p
\mb{二路插入}\p
\mb{表插入}\p

\newpage
\mb{希尔排序}

\begin{lstlisting}[style=v1]

    void ShellInsort(Sqlist &L，int dk){
        //对顺序表做希尔插入排序
        //1.位置增量dk
        //2.L.r[0]是暂存不是哨兵，j<=0时插入位置已找到
        for(i=dk+1;i<=L.length;i++){
            if(LT(L.r[i].key,L.r[i-dk].key)){ //"<",需将L.r[i]插入有序子表
                L.r[0]=L.r[i];               //暂存L.r[0]
                for(j=i-dk;j>0 && LT(L.r[0].key,L.r[j].key);j-=dk)
                    L.r[j+dk]=L.r[j];         //记录后移,查找插入位置
                L.r[j+dk]=L.r[0];             //插入正确位置
            }
        }
    }//ShellInsort

    void ShellSort(Sqlist &L，int dk[],int t){
        //按增量序列 dk[0...t-1]对顺序表做希尔插入排序
        for(k=0;k<t;k++){
            ShellInsort(L,dk[k]);     //一趟增量为dk[k]的插入排序
        }
    }//ShellSort


\end{lstlisting}

 

\subsection{快速}
\subsubsection{起泡排序}

\begin{lstlisting}[style=v1]
    void BubbleSort(int a[],int n){
        for(i=n-1,change=TRUE;i>=1 && change;--i){
            change=FALSE;
            for(j=0;j<i,j++){
                if(a[j]>a[i]){SWAP(a[j],a[i]);change=TRUE;}
            }
        }
    }
\end{lstlisting}



\subsubsection{快速排序}
 
\begin{lstlisting}[style=v1]
    void Partition(Sqlist &L,int low,int high){
        //交换顺序表L中子序列L.r[low...high]的记录，枢轴记录到位，返回位置此时
        //在枢轴前（后）记录不大于（不小于）它
        L.r[0]=L.r[low];        //第一个记录做枢轴
        pivotkey=L.r[low].key;  //枢轴记录关键字
        while(low<high){        //从表的两端交替向中间扫描
            while(low<high && L.r[high].key>=pivotkey) --high;
            L.r[low]=L.r[high];  //小的左移
            while(low<high && L.r[low]<=pivotkey) ++low;
            L.r[high]=L.r[low];  //大的右移   
        }
        L.r[low]=L.r[0];         //枢轴到位  
        return low;              //返回枢轴位置  
    }

    void QSort(Sqlist &L,int low,int high){
        //对顺序表L中子序列L.r[low...high]作快速排序
        if(low<high){                       //长度大于1
            pivotkey=Partition(L,low,high); //将L.r[low...high]一分为二
            QSort(L,low,pivotkey-1);        //低子表递归
            QSort(L,pivotkey+1,high);       //高子表递归
        }
    }

    void QuickSort(Sqlist &L){
        //对顺序表L作快速排序
        QSort(L,1,L.length)
    }

\end{lstlisting}
 
\subsection{选择排序}
 
\subsubsection{简单选择排序}

\begin{lstlisting}[style=v1]
    void SelectSort(Sqlist &L ){
        for(i=1;i<L.length;i++){        //选择第i小的记录，并交换到位
            j=SelectMinKey(L,i);        //在L.r[i...L.length]中选择key最小的记录
            if(i!=j) SWAP(L.r[i],L.r[j]) //与第i个记录交换
        }
    }
\end{lstlisting}
\subsubsection{树形排序}

% \newpage
\subsubsection{堆排序}


\begin{lstlisting}[style=v1]
    void HeapAdjust(HeapType &H,int s ,int m ){
        //已知H.r[s...m]中记录除H.r[s]外均满足堆的定义
        //调整H.r[s]使得H.r[s...m]称为大顶堆
        rc=H.r[s];
        for(j=2*s;j<=m;j*=2){    //沿key较大的孩子节点向下筛选
            if(j<m && LT(H.r[j].key,H.r[j+1].key)) ++j; //j为key较大的记录的下标
            if(!LT(rc.key,H.r[j].key)) break;           //rc插入s    
            H.r[s]=H.r[j];s=j;                           //插入   
        }
        H.r[s]=rc;
    }
 
    void HeapSort(HeapType &H ){
        for(i=H.length/2;;i>0;--i)            //把H.r[1...H.length]建成大顶堆          
            HeapAdjust(H,i,H.length);           
        for(i=H.length;i>1;--i){               //堆顶记录和未经排序子序列H.r[1...i]中最后一个记录交换 
            SWAP(H.r[1],H.r[i]);                //将[1...i-1]建成大顶堆
            HeapAdjust(H,1,i-1); 
        }
    }
 
\end{lstlisting}





\subsection{归并排序}

\begin{lstlisting}[style=v1]
    void Merge(RcdType SR[],RcdType & TR[],int i,int m,int n ){
        //将有序的SR[i...m],SR[m+1,n]归并为有序的TR[i...n]
        for(j=m+1,k=i;i<=m && j<=n;++k){  //将SR中记录从小到大并入TR
            if(LQ(SR[i].key,SR[j].key))  TR[k]=SR[i++];
            else TR[k]=SR[j++];
        }
        if(i<=m) TR[K...n]=SR[i...m];       //将剩余的SR[i...m]复制到TR[K...n]
        if(j<n)  TR[k...n]=SR[j...n];       //将剩余的SR[j...n]复制到TR[K...n]
    }

    void Msort(RcdType SR[],RcdType & TR1[],int s,int t){
        //将SR[s...t]归并为TR1[s...t]
        if(s==t) TR1[s]=SR[s];
        else{
            m=(s+t)/2;           //将SR[s...t]平分为SR[s...m]，SR[m+1...t]
            Msort(SR,TR2,s,m);   //递归SR[s...m] 为有序 TR2[s...m]  
            Msort(SR,TR2,m+1,t);  //递归SR[m+1...t]为有序 TR2[m+1...t] 
            Merge[TR2,TR1,s,m.t]; //将TR2[s...m],TR2[m+1...t] 归并到 TR1[s...t] 
        }
    }

    void MergeSort(Sqlist &L){
        Msort(L.r,L.r,1,L.length);
    }

\end{lstlisting}



\subsection{基数排序}

\subsubsection{多关键字的排序}

\subsubsection{链式基数排序}
 
% \newpage
\begin{lstlisting}[style=v1]
 #define MAX_NUM_OF_KEY 8
 #define RADIX 10
 #define MAX_SPACE 10000
 typedef struct{
    KeysType Keys[MAX_NUM_OF_KEY];
    InfoType ontheritems;
    int next;
 }SLCell;

 typedef struct{
    SLCell r[MAX_SPACE];
    int keynum;
    int recnum;
 }SLList;

 typedef int ArrType[RADIX];


void Distribute(SLCell &r,int i,ArrType &f,ArrType &e){
    //静态链表L的r域中记录已按keys[0]...keys[i-1]有序
    //本算法按第i个关键字keys[i]建立RADIX个子表，使得同一子表中记录的keys[i]相同
    //f[0...RADIX-1],e[0...RADIX-1]分别指向各子表中第一个和最后一个记录
    for(j=0;j<Radix;++j) f[j]=0 //各子表初始化为空
    for(p=r[0].next;p;p=r[p].next){
        j=ord(r.[p].keys[i]);   //ord将记录中第i个关键字映射到[0...RADIX-1]
        if(!f[j]) f[j]=p;
        else r[e[j]].next=p;
        e[j]=p;                 //将p指向的结点插入第j个子表中
    }
}//Distribute

void Collect(SLCell &r,int i,ArrType f,ArrType e){
    //本算法按keys[i]从小至大地将f[0...RADIX-1]所指个子表依次链接成一个链表
    //e[0...RADIX-1]为各子表的尾指针
    for(j=0;!f[j];j=succ(j));    //找到第一个非空子表，succ为求后继函数
    r[0].next=f[j];t=e[j];       //r[0].next指向第一个非空子表中第一个节点
    while(j<RADIX){
        for(j=succ(j);j<RADIX-1 && !f[j];j=succ(j));  //找到下一个非空子表
        if(f[j] {r[t].next=f[j];t=e[j];})             //链接两个非空子表 
    }                   
    r[t].next=0;                                      //t指向最后一个非空子表中的最后一个节点 
}//Collect

void RadixSort(SLList &L){
    //L是采用静态链表表示的顺序表
    //对L作基数排序，使得L成为按关键字自小到大的有序静态链表，L.r[0]为头节点
    for(i=0;i<L.recnum;++i) L.r[i].next=i+1;
    L.r[L.recnum].next=0;           //将改造为静态链表
    for(i=0;i<L.keynum;++i){        //按最低位优先依次对各关键字进行分配和收集   
        Distribute(L.r,i,f,e);      //第i趟分配
        Collect(L.r,i,f,e);         //第i趟收集
    }
}//RadixSort


\end{lstlisting}


\subsection{各内部排序方法的比较讨论}


\begin{center}
    \begin{tabular}{ccccc}
        \toprule
        排序方法 & 平均时间 & 最坏情况 & 辅助存储   \\
        \midrule
        简单排序 & $O(n^2)$     &  $O(n^2)$ & $O(1)$  \\
        快速排序 & $O(nlogn)$   & $O(n^2)$  & $O(logn)$  \\
        堆排序   & $O(nlogn)$   & $O(nlogn)$  & $O(1)$  \\
        归并排序 & $O(nlogn)$   & $O(nlogn)$  & $O(n)$  \\
        基数排序 & $O(d(n+rd))$ & $O(d(n+rd))$  & $O(rd)$  \\
        \bottomrule
    \end{tabular}%
\end{center}


 

简单排序包括除希尔排序之外所有插入排序，起泡排序，简单选择排序，直接插入排序

% \newpage
\mb{地址向量重排算法}

\begin{lstlisting}[style=v1]
    void Rearrange(Sqlist &L,int adr[] ){
        //adr给出顺序表的有序次序，即L.r[adr[i]]是第i小记录
        //本算法按adr重排L.r使其有序
        for(i=1;i<L.length;++i){
            if(adr[i]!=i){
                j=i;L.r[0]=L.r[i];            //暂存记录  
                while(adr[j]!=i){             //调整L.r[adr[j]]的记录到位直到adr[j]=i为止  
                    k=adr[j];L.r[j]=L.r[k];     
                    adr[j]=j;j=k;
                }
                L.r[j]=L.r[0];adr[j]=j;       //记录按序到位 
            }
        }
    }
\end{lstlisting}


\newpage
\section{外部排序}
\newpage
\section{文件}










% \begin{lstlisting}[style=v1]
%     void  ( ){
 
%     }
% \end{lstlisting}







\end{document}