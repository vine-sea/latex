\documentclass[UTF8]{ctexart}
\usepackage{anyfontsize}  %去除ctex字體報錯
\usepackage{amsmath}
\usepackage{amssymb} 
\usepackage{extarrows}
\usepackage{titlesec}
\usepackage{titletoc}
\usepackage{tikz}

\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{setspace}
\usepackage{indentfirst}

\usepackage{listings}

\lstdefinestyle{v1}{
language={C},
basicstyle=\scriptsize\tt,
% basicstyle=\footnotesize\tt,
keywordstyle=\color{blue}\bfseries,
stringstyle=\color{green!50!black},
identifierstyle=\color{brown!50!black},
showstringspaces=false,
commentstyle=\color{gray},
% backgroundcolor=\color[RGB]{245,245,244},
frameround = fftt,
frame=shadowbox,  
tabsize=2,
xleftmargin=1cm, 
xrightmargin=3cm,
rulecolor=\color{gray},  
rulesepcolor=\color{gray}  
} 


\usetikzlibrary{arrows,backgrounds}



 
\renewcommand{\headrulewidth}{0pt}  
\renewcommand{\footrulewidth}{0pt}  
\renewcommand{\headwidth}{\textwidth}
\newcommand{\mb}[1]{\textbf{#1}}
\newcommand{\p}{\par}
 


\title{Data Structure}
\author{Vine}
\date{\today}

\geometry{papersize={21cm,29.7cm}}
\geometry{left=1cm,right=1cm,top=2cm,bottom=2cm}
\pagestyle{fancy}


\lhead{Vine }
\chead{}
\rhead{}

\lfoot{}
\cfoot{\thepage }
\rfoot{}


\onehalfspacing




\begin{document}
    

\setlength{\headheight}{15pt}
\maketitle %和頁眉衝突
\newpage
\tableofcontents{}

\newpage
\section{绪论}
\newpage
\section{线性表}
\newpage
\section{栈和队列}
\newpage
\section{串}
\newpage
\section{数组和广义表}
\newpage
\section{树和二叉树}
\newpage
\section{图}
\newpage
\section{动态存储管理}
\newpage
\section{查找}

\newpage
\section{内部排序}


\subsection{概述}
\subsection{插入排序}
\subsubsection{直接插入}

\begin{lstlisting}[style=v1]
    void InsertSort(Sqlist &L){
        //对顺序表做直接插入排序
        for(i=2;i<=L.length;i++){
            if(LT(L.r[i].key,L.r[i-1].key)){ //"<",需将L.r[i]插入有序子表
                L.r[0]=L.r[i];               //复制为哨兵
                L.r[i]=L.r[i-1];
                for(j=i-2;LT(L.r[0].key,L.r[j].key);--j)
                    L.r[j+1]=L.r[j];         //记录后移  
                L.r[j+1]=L.r[0];             //插入正确位置
                printf("vine");
            }
        }
    }//InsertSort
\end{lstlisting}

\subsubsection{其他插入}

\mb{折半插入}
\begin{lstlisting}[style=v1]
    void BInsertSort(Sqlist &L){
        //对顺序表做折半插入排序
        for(i=2;i<=L.length;i++){
            L.r[0]=L.r[i];                  //将L.r[i]暂存到L.r[0]
            low=1,high=i-1;
            while(low<=high){               //在L.r[low...high]中折半查找有序插入位置
                m=(low+high)/2;             //折半
                if(LT(L.r[0].key,L.r[m].key)) high=m-1; //插入点在高
                else low =m+1;                          //插入点在低   
            }
            for(j=i-1;j>=high+1;--j) L.r[j+1]=L.r[j];   //记录后移
            L.r[high+1]=L.r[0];                         //插入
        }
    }//BInsertSort
\end{lstlisting}\p
\mb{二路插入}\p
\mb{表插入}\p

% \newpage
\mb{希尔排序}

\begin{lstlisting}[style=v1]

    void ShellInsort(Sqlist &L，int dk){
        //对顺序表做希尔插入排序
        //1.位置增量dk
        //2.L.r[0]是暂存不是哨兵，j<=0时插入位置已找到
        for(i=dk+1;i<=L.length;i++){
            if(LT(L.r[i].key,L.r[i-dk].key)){ //"<",需将L.r[i]插入有序子表
                L.r[0]=L.r[i];               //暂存L.r[0]
                for(j=i-dk;j>0 && LT(L.r[0].key,L.r[j].key);j-=dk)
                    L.r[j+dk]=L.r[j];         //记录后移,查找插入位置
                L.r[j+dk]=L.r[0];             //插入正确位置
            }
        }
    }//ShellInsort

    void ShellSort(Sqlist &L，int dk[],int t){
        //按增量序列 dk[0...t-1]对顺序表做希尔插入排序
        for(k=0;k<t;k++){
            ShellInsort(L,dk[k]);     //一趟增量为dk[k]的插入排序
        }
    }//ShellSort


\end{lstlisting}

 

\subsection{快速}
\subsubsection{起泡排序}

\begin{lstlisting}[style=v1]
    void BubbleSort(int a[],int n){
        for(i=n-1,change=TRUE;i>=1 && change;--i){
            change=FALSE;
            for(j=0;j<i,j++){
                if(a[j]>a[i]){SWAP(a[j],a[i]);change=TRUE;}
            }
        }
    }
\end{lstlisting}



\subsubsection{快速排序}
 
\begin{lstlisting}[style=v1]
    void Partition(Sqlist &L,int low,int high){
        //交换顺序表L中子序列L.r[low...high]的记录，枢轴记录到位，返回位置此时
        //在枢轴前（后）记录不大于（不小于）它
        L.r[0]=L.r[low];        //第一个记录做枢轴
        pivotkey=L.r[low].key;  //枢轴记录关键字
        while(low<high){        //从表的两端交替向中间扫描
            while(low<high && L.r[high].key>=pivotkey) --high;
            L.r[low]=L.r[high];  //小的左移
            while(low<high && L.r[low]<=pivotkey) ++low;
            L.r[high]=L.r[low];  //大的右移   
        }
        L.r[low]=L.r[0];         //枢轴到位  
        return low;              //返回枢轴位置  
    }

    void QSort(Sqlist &L,int low,int high){
        //对顺序表L中子序列L.r[low...high]作快速排序
        if(low<high){                       //长度大于1
            pivotkey=Partition(L,low,high); //将L.r[low...high]一分为二
            QSort(L,low,pivotkey-1);        //低子表递归
            QSort(L,pivotkey+1,high);       //高子表递归
        }
    }

    void QuickSort(Sqlist &L){
        //对顺序表L作快速排序
        QSort(L,1,L.length)
    }

\end{lstlisting}
 
\subsection{选择排序}
 
\subsubsection{简单选择排序}

\begin{lstlisting}[style=v1]
    void SelectSort(Sqlist &L ){
        for(i=1;i<L.length;i++){        //选择第i小的记录，并交换到位
            j=SelectMinKey(L,i);        //在L.r[i...L.length]中选择key最小的记录
            if(i!=j) SWAP(L.r[i],L.r[j]) //与第i个记录交换
        }
    }
\end{lstlisting}
\subsubsection{树形排序}

\newpage
\subsubsection{堆排序}


\begin{lstlisting}[style=v1]
    void HeapAdjust(HeapType &H,int s ,int m ){
        //已知H.r[s...m]中记录除H.r[s]外均满足堆的定义
        //调整H.r[s]使得H.r[s...m]称为大顶堆
        rc=H.r[s];
        for(j=2*s;j<=m;j*=2){    //沿key较大的孩子节点向下筛选
            if(j<m && LT(H.r[j].key,H.r[j+1].key)) ++j; //j为key较大的记录的下标
            if(!LT(rc.key,H.r[j].key)) break;           //rc插入s    
            H.r[s]=H.r[j];s=j;                           //插入   
        }
        H.r[s]=rc;
    }
 
    void HeapSort(HeapType &H ){
        for(i=H.length/2;;i>0;--i)            //把H.r[1...H.length]建成大顶堆          
            HeapAdjust(H,i,H.length);           
        for(i=H.length;i>1;--i){               //堆顶记录和未经排序子序列H.r[1...i]中最后一个记录交换 
            SWAP(H.r[1],H.r[i]);                //将[1...i-1]建成大顶堆
            HeapAdjust(H,1,i-1); 
        }
    }
 
\end{lstlisting}





\subsection{归并排序}

\begin{lstlisting}[style=v1]
    void Merge(RcdType SR[],RcdType & TR[],int i,int m,int n ){
        //将有序的SR[i...m],SR[m+1,n]归并为有序的TR[i...n]
        for(j=m+1,k=i;i<=m && j<=n;++k){  //将SR中记录从小到大并入TR
            if(LQ(SR[i].key,SR[j].key))  TR[k]=SR[i++];
            else TR[k]=SR[j++];
        }
        if(i<=m) TR[K...n]=SR[i...m];       //将剩余的SR[i...m]复制到TR[K...n]
        if(j<n)  TR[k...n]=SR[j...n];       //将剩余的SR[j...n]复制到TR[K...n]
    }

    void Msort(RcdType SR[],RcdType & TR1[],int s,int t){
        //将SR[s...t]归并为TR1[s...t]
        if(s==t) TR1[s]=SR[s];
        else{
            m=(s+t)/2;           //将SR[s...t]平分为SR[s...m]，SR[m+1...t]
            Msort(SR,TR2,s,m);   //递归SR[s...m] 为有序 TR2[s...m]  
            Msort(SR,TR2,m+1,t);  //递归SR[m+1...t]为有序 TR2[m+1...t] 
            Merge[TR2,TR1,s,m.t]; //将TR2[s...m],TR2[m+1...t] 归并到 TR1[s...t] 
        }
    }

    void MergeSort(Sqlist &L){
        Msort(L.r,L.r,1,L.length);
    }

\end{lstlisting}



\subsection{基数排序}

\newpage
\section{外部排序}
\newpage
\section{文件}










% \begin{lstlisting}[style=v1]
%     void  ( ){
 
%     }
% \end{lstlisting}







\end{document}